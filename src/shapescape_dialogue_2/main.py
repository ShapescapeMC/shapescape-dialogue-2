import sys
from pathlib import Path
from typing import Callable, Optional

from .compiler import CompileError
from .generator import Context, GeneratorError, generate
from .parser import ParseError, build_ast, tokenize


def main(
        source_file: Path,
        bp_path: Optional[Path],
        rp_path: Optional[Path],
        namespace: str,

        debug_log_tokens: bool=False,
        debug_log_ast: bool=False,
        debug_skip_packs_output: bool=False) -> None:
    # TODO - log_compiled and log_generated
    '''
    :param source_file: the path to the source file with the code that defines
        the dialogue. The name of the file is also used as part of various
        identifiers of the output files.
    :param bp_path: the output path for the behavior files (the behavior pack
        folder).
    :param rp_path: the output path for the resource files (the resource pack
        folder).
    :param namespace: the namespace to use for the generated entity.
    '''
    if bp_path is None or rp_path is None:
        if not debug_skip_packs_output:
            raise GeneratorError(
                "The output paths for the packs must be specified unless "
                "you're running in debug mode and want to skip the output.")
        bp_path = Path("BP")
        rp_path = Path("RP")

    if debug_log_tokens or debug_log_ast:
        import prettyprinter
        prettyprinter.install_extras(
            include=[
                'dataclasses',
            ],
            warn_on_error=True
        )
        # Debug paths
        log_tokens_path = Path("log_tokens.txt")
        log_ast_path = Path("log_ast.txt")

    # Read the source
    with source_file.open("r", encoding='utf8') as f:
        source = f.readlines()

    # Tokenize
    tokens = tokenize(source)
    if debug_log_tokens:
        with log_tokens_path.open("w", encoding='utf8') as f:
            for token in tokens:
                print(token, file=f)
    
    # Build the AST
    tree = build_ast(tokens)
    if debug_log_ast:
        with log_ast_path.open("w", encoding='utf8') as f:
            prettyprinter.pprint(tree, stream=f)

    # Setup the context
    context = Context(
        bp_path=bp_path,
        rp_path=rp_path,
        subpath=source_file.stem,
        namespace=namespace,
    )
    # Generate files
    if not debug_skip_packs_output:
        generate(tree, context)

def main_commandline() -> None:
    '''
    Commandline interface for running the main() function. Example usage:

    shapescape-dialogue-2 my_awesome_dialogue.txt --namespace "shapescape"
    --bp-path "generated/BP" --rp-path "generated/RP"
    '''
    # Lol easy, this was almost entirely generated by GitHub Copilot.
    import argparse
    parser = argparse.ArgumentParser(
        description=(
            'Generate Minecraft entity for playing dialoges in and controling '
            'camera movement in cutscenes.'))
    parser.add_argument(
        'source_file',
        type=Path,
        help=(
            'The path to the source file with the code that defines the '
            'dialogue. The name of the file is also used as part of various '
            'identifiers of the output files.')
    )
    parser.add_argument(
        '--namespace',
        required=True,
        type=str,
        help='The namespace to use for the generated entity.'
    )
    parser.add_argument(
        '--bp-path',
        type=Path,
        required=False,
        help=(
            'The output path for the behavior files (the behavior pack '
            'folder).')
    )
    parser.add_argument(
        '--rp-path',
        type=Path,
        required=False,
        help=(
            'The output path for the resource files (the resource pack '
            'folder).')
    )
    parser.add_argument(
        '--debug-log-tokens',
        action='store_true',
        help='Log the tokens to a file.'
    )
    parser.add_argument(
        '--debug-log-ast',
        action='store_true',
        help='Log the AST to a file.'
    )
    parser.add_argument(
        '--debug-skip-packs-output',
        action='store_true',
        help='Skip outputting the packs.'
    )
    parser.add_argument(
        '--debug-print-stack-traces',
        action='store_true',
        help='Print stack traces of the errors.'
    )
    args = parser.parse_args()
    if not args.debug_skip_packs_output:
        if args.bp_path is None or args.rp_path is None:
            print(
                "If the --debug-skip-packs-output flag is not specified "
                "then the --bp-path and --rp-path flags must be specified.",
                file=sys.stderr)
            sys.exit(1)
    
    run: Callable[[], None] = lambda: main(
        source_file=args.source_file,
        bp_path=args.bp_path,
        rp_path=args.rp_path,
        namespace=args.namespace,
        debug_log_tokens=args.debug_log_tokens,
        debug_log_ast=args.debug_log_ast,
        debug_skip_packs_output=args.debug_skip_packs_output
    )

    if args.debug_print_stack_traces:
        run()
    else:
        try:
            run()
        except (ParseError, CompileError, GeneratorError) as e:
            print(f"ERROR: {e}", file=sys.stderr)
            exit(1)
